{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"SunSolve","text":"<p>Documentation: https://nkalis.github.io/sunsolve</p> <p>Source Code: https://github.com/nkalis/sunsolve</p> <p>PyPI: https://pypi.org/project/sunsolve/</p> <p>A python package for solving the inverse problem of matching LEDs to the sun\u2019s spectrum</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install sunsolve\n</code></pre>"},{"location":"#development","title":"Development","text":"<ul> <li>Clone this repository</li> <li>Requirements:</li> <li>Poetry</li> <li>Python 3.7+</li> <li>Create a virtual environment and install the dependencies</li> </ul> <pre><code>poetry install\n</code></pre> <ul> <li>Activate the virtual environment</li> </ul> <pre><code>poetry shell\n</code></pre>"},{"location":"#testing","title":"Testing","text":"<pre><code>pytest\n</code></pre>"},{"location":"#documentation","title":"Documentation","text":"<p>The documentation is automatically generated from the content of the docs directory and from the docstrings  of the public signatures of the source code. The documentation is updated and published as a Github project page   automatically as part each release.</p>"},{"location":"#releasing","title":"Releasing","text":"<p>Trigger the Draft release workflow (press Run workflow). This will update the changelog &amp; version and create a GitHub release which is in Draft state.</p> <p>Find the draft release from the GitHub releases and publish it. When  a release is published, it'll trigger release workflow which creates PyPI  release and deploys updated documentation.</p>"},{"location":"#pre-commit","title":"Pre-commit","text":"<p>Pre-commit hooks run all the auto-formatters (e.g. <code>black</code>, <code>isort</code>), linters (e.g. <code>mypy</code>, <code>flake8</code>), and other quality  checks to make sure the changeset is in good shape before a commit/push happens.</p> <p>You can install the hooks with (runs for each commit):</p> <pre><code>pre-commit install\n</code></pre> <p>Or if you want them to run only for each push:</p> <pre><code>pre-commit install -t pre-push\n</code></pre> <p>Or if you want e.g. want to run all checks manually for all files:</p> <pre><code>pre-commit run --all-files\n</code></pre>"},{"location":"api_docs/","title":"API documentation","text":""},{"location":"api_docs/#sunsolve.fitness_function","title":"<code>fitness_function</code>","text":""},{"location":"api_docs/#sunsolve.fitness_function.fit_sum","title":"<code>fit_sum(fits_per_bin)</code>","text":"<p>This is a function that uses a normalized normal disctribution to add a weighted score to how close the LED simulation is to each bin of the solar spectrum. The normal distribution is fitted around a mean of 1, which when using a standard deviation of 0.35, would give a maximum score of 1 per bin (ie: a bin with 50% or 150% of the power of the solar spectrum has a score of 0.36). Therefore if there are 10 bins, the maximum score is 10 (perfect fit), and the lowest score is 0.</p> <p>Parameters:</p> Name Type Description Default <code>fits_per_bin</code> <code>_type_</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>fit_sum</code> <code>_type_</code> <p>description</p> <code>fit_weight</code> <code>_type_</code> <p>description</p> Source code in <code>src/sunsolve/fitness_function.py</code> <pre><code>def fit_sum(fits_per_bin):\n\"\"\"This is a function that uses a normalized normal disctribution to add a weighted score to how close the LED simulation is to each\n    bin of the solar spectrum. The normal distribution is fitted around a mean of 1, which when using a standard deviation of 0.35, would\n    give a maximum score of 1 per bin (ie: a bin with 50% or 150% of the power of the solar spectrum has a score of 0.36). Therefore if\n    there are 10 bins, the maximum score is 10 (perfect fit), and the lowest score is 0.\n\n    Args:\n        fits_per_bin (_type_): _description_\n\n    Returns:\n        fit_sum (_type_): _description_\n        fit_weight (_type_): _description_\n    \"\"\"\n    fit_weight = []\n    for fit in fits_per_bin:\n        fit_weight.append(stats.norm.pdf(fit, 1, 0.35) / stats.norm.pdf(1, 1, 0.35))\n\n    fit_sum = sum(fit_weight)\n\n    return fit_sum, fit_weight\n</code></pre>"},{"location":"api_docs/#sunsolve.fitness_function.main_calc","title":"<code>main_calc(solution, led_df, am)</code>","text":"<p>This is the main formuka</p> <p>Parameters:</p> Name Type Description Default <code>solution</code> <code>_type_</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>_type_</code> <p>description</p> Source code in <code>src/sunsolve/fitness_function.py</code> <pre><code>def main_calc(solution, led_df, am):\n\"\"\"This is the main formuka\n\n    Args:\n        solution (_type_): _description_\n\n    Returns:\n        _type_: _description_\n    \"\"\"\n    # Take the first half of the chromosome and uses it for brightness. Value is then normalised w.r.t number of values possible.\n    brightness = solution[: len(solution) // 2]\n    brightness = brightness / (len(led_df.index))\n    # Take the second half of the chromosome and use it for the identification of the LED in the LED database\n    solution = solution[len(solution) // 2 :]\n    # Total power (area under curve)\n    tot_pow = 0\n    # ys = spectral irradiance [W^2/m^2/nm]\n    ys = np.zeros(1500)\n    xs = np.linspace(0, 1500, 1500)\n\n    # Iterate through LEDs in solution. Simulate their wavelength and power output using a gaussian distribution and distance from the 'measuring device'.\n    for x in range(len(solution)):\n        # Select single solution and corresponding brightness of LED\n        led = solution[x]\n        bright = brightness[x]\n        # Retrieve properties of the LED from the database\n        power = led_df[\"Output Power (mw)\"][led] * bright\n        theta = led_df[\"Viewing Angle (deg)\"][led]\n        wavelength = led_df[\"Peak wavelength (nm)\"][led]\n        fwhm = led_df[\"FWHM (nm)\"][led]\n        # Physical constraints\n        d = 0.30  # Distance from measurement device [m]\n        r = np.tan(np.deg2rad(theta / 2)) * d  # radius of beam swadth [m^2]\n        a = np.pi * r**2  # Area of beam swadth [m^2]\n        power_den = (power / 1000) / a  # power density [W/m^2]\n        # Sum the total power of all LEDs\n        tot_pow = tot_pow + power_den\n        # Simulate wavelength distribution \u00b14 standard deviations from peak-power wavelength\n        std_dev = fwhm / 2.3548\n        x_min = wavelength - (std_dev * 4)\n        x_max = wavelength + (std_dev * 4)\n        x, step = np.linspace(x_min, x_max, 20, retstep=True)\n        y = scipy.stats.norm.pdf(x, wavelength, std_dev)\n        y = y * power_den\n        ys = ys + np.interp(xs, x, y, left=0, right=0)\n\n    # Calculate exact number of LED panels would be required\n    num_panels = np.ceil(1036.7156 / np.trapz(ys, xs))\n    # Scale output of one panel to total number of panels\n    ys = ys * num_panels\n    # Evalation bins\n    bins = list(range(350, 1250, 100))\n    fits = []\n    for x in range(len(bins) - 1):\n        # Calculate actual solar power between two wavelengths from the bins\n        # Get index of closest values\n        idx1 = am[\"Wavelength (nm)\"].sub(bins[x]).abs().idxmin()\n        idx2 = am[\"Wavelength (nm)\"].sub(bins[x + 1]).abs().idxmin()\n        sol = simps(am[\"W*m-2*nm-1\"][idx1:idx2], am[\"Wavelength (nm)\"][idx1:idx2])\n        # Calculate simulated solar power between two wavelengths from the bins\n        idx3 = (np.abs(xs - bins[x])).argmin()\n        idx4 = (np.abs(xs - bins[x + 1])).argmin()\n        sim = simps(ys[idx3:idx4])\n        # Find the % power difference between the two\n        fits.append(sim / sol)\n\n    bin_perc = fits\n    fit, fit_weight = fit_sum(fits)\n\n    return fits, fit, fit_weight, bins, bin_perc, xs, ys\n</code></pre>"},{"location":"changelog/","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p>"},{"location":"changelog/#unreleased","title":"Unreleased","text":""},{"location":"changelog/#004-2023-05-18","title":"0.0.4 - 2023-05-18","text":""},{"location":"changelog/#fixed","title":"Fixed","text":"<ul> <li>github release action fixed to build and release properly.</li> </ul>"},{"location":"changelog/#003-2023-05-18","title":"0.0.3 - 2023-05-18","text":""},{"location":"changelog/#added","title":"Added","text":"<ul> <li>Project restructure (yes already, I'm still learning)</li> </ul>"},{"location":"changelog/#002-2023-05-18","title":"0.0.2 - 2023-05-18","text":""},{"location":"changelog/#added_1","title":"Added","text":"<ul> <li>Initial (working) release for base project structure.</li> </ul>"}]}